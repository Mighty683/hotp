import { TOTPOptions, HOTPOptions, AlgorithmOption } from "./types";
import { browserHmac, isNodeEnv, nodeHmac, padZeroStart } from "./helpers";

/**
 * 
 * TOTP: Time-Based One-Time Password Algorithm
 * https://www.rfc-editor.org/rfc/rfc6238
 * @param secret - shared secret between client and server; each HOTP
  generator has a different and unique secret K.
 * @param options.t0 - is the Unix time to start counting time steps, default 0
 * @param options.timestamp - Unix time for which we will generate TOTP
 * @param options.digitsCount - number of digits generated by TOTP, default 6
 * @param options.stepTime - time in seconds how long step is valid, default 30
 * @returns
 */
export async function generateTOTP(secret: string, options: TOTPOptions) {
  let stepTime = options.stepTime || 30;
  let _t0 = options.t0 || 0;
  let stepCounter = Math.floor((options.timestamp - _t0) / 1000 / stepTime);
  return generateHOTP(secret, stepCounter, options);
}

/**
 * HOTP: An HMAC-Based One-Time Password Algorithm
 * https://www.rfc-editor.org/rfc/rfc4226
 * @param secret - shared secret between client and server; each HOTP
  generator has a different and unique secret K.
 * @param counter - integer counter value, the moving factor.  This counter
    MUST be synchronized between the HOTP generator (client)
    and the HOTP validator (server).
 * @param options.digitsCount - length of generated HOTP, default 6
 * @param options.algorithm - algorithm used possible values: sha-1, sha-256, default: sha-1
  
 * @returns 
 */
export async function generateHOTP(
  secret: string,
  counter: number,
  options?: HOTPOptions
): Promise<string> {
  let hmacResult = await hmac(secret, counter, options?.algorithm);

  let digitsCount = options?.digitsCount || 6;
  let codeValue = dynamicTruncate(hmacResult) % 10 ** digitsCount;
  let result = codeValue.toString();

  return padZeroStart(result, digitsCount);
}

function dynamicTruncate(source: ArrayBuffer) {
  let offset = source[source.byteLength - 1] & 0xf;
  return (
    ((source[offset] & 0x7f) << 24) |
    ((source[offset + 1] & 0xff) << 16) |
    ((source[offset + 2] & 0xff) << 8) |
    (source[offset + 3] & 0xff)
  );
}

async function hmac(
  secret: string,
  counter: number,
  algorithm: AlgorithmOption
): Promise<Uint8Array> {
  if (isNodeEnv()) {
    return nodeHmac(secret, counter, algorithm);
  } else {
    return browserHmac(secret, counter, algorithm);
  }
}
