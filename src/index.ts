import {
  TOTPOptions,
  HOTPOptions,
  OCRAOptions,
  OCRASuiteString,
} from "./types";

import {
  createOCRADataInput,
  dynamicTruncate,
  hmac,
  padZeroStart,
  parseOCRASuite,
} from "./helpers";

import { OCRAAlgorithmMap } from "./enums";

/**
 * 
 * TOTP: Time-Based One-Time Password Algorithm
 * https://www.rfc-editor.org/rfc/rfc6238
 * @param secret - shared secret between client and server; each HOTP
  generator has a different and unique secret K.
 * @param options.t0 - is the Unix time to start counting time steps, default 0
 * @param options.timestamp - Unix time for which we will generate TOTP
 * @param options.digitsCount - number of digits generated by TOTP, default 6
 * @param options.stepTime - time in seconds how long step is valid, default 30
 * @returns
 */
export async function generateTOTP(secret: string, options: TOTPOptions) {
  let stepTime = options.stepTime || 30;
  let _t0 = options.t0 || 0;
  let stepCounter = Math.floor((options.timestamp - _t0) / 1000 / stepTime);
  return generateHOTP(secret, stepCounter, options);
}

/**
 * HOTP: An HMAC-Based One-Time Password Algorithm
 * https://www.rfc-editor.org/rfc/rfc4226
 * @param secret - shared secret between client and server; each HOTP
  generator has a different and unique secret K.
 * @param counter - integer counter value, the moving factor.  This counter
    MUST be synchronized between the HOTP generator (client)
    and the HOTP validator (server).
 * @param options.digitsCount - length of generated HOTP, default 6
 * @param options.algorithm - algorithm used possible values: sha-1, sha-256, default: sha-1
  
 * @returns 
 */
export async function generateHOTP(
  secret: string,
  counter: number,
  options?: HOTPOptions
): Promise<string> {
  let hmacResult = await hmac(secret, counter, options?.algorithm);

  let digitsCount = options?.digitsCount || 6;
  let codeValue = dynamicTruncate(hmacResult) % 10 ** digitsCount;
  let result = codeValue.toString();

  return padZeroStart(result, digitsCount);
}

/**
 * OCRA: OATH Challenge-Response Algorithm
 * https://www.rfc-editor.org/rfc/rfc6287
 *
 * @param options.question - number or string or ByteArray
 * if string can be alphanumerical or number string eg: "00000000"
 * depends on question type.
 */
export async function generateOCRA(secret: string, options: OCRAOptions) {
  let OCRAConfig = parseOCRASuite(options.suite);
  let dataInput = createOCRADataInput(options, OCRAConfig);
  let hmacResult = await hmac(
    secret,
    dataInput,
    OCRAAlgorithmMap[OCRAConfig.algorithm]
  );
  let codeValue = dynamicTruncate(hmacResult) % 10 ** OCRAConfig.digitsCount;

  let result = codeValue.toString();

  return padZeroStart(result, OCRAConfig.digitsCount);
}
